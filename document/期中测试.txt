程序设计入门—C 语言
期中测评
1 在代码：
while ( !e )
中，!e 等价于：
A.e ==0 B. e != 1 C. e!=0 D. e == 1

* 只有当e的逻辑为false时这个表达式才成立，!false=true  
* 而对于整数e而言，任何非0的整数值都是逻辑的true，换句话说只有整数0才代表逻辑false，因此!e换一个写法既是e == 0
因此选 A

2. 以下代码片段的输出是：
int j=4;
for ( int i=j; i<=2*j; i++ ) {
switch ( i/j ) {
case 0:
case 1: printf(“*”); break;
case 2: printf(“#”);
}
}
A.****## B. ***# C. *# D. ****# E. ****

表格模拟：
j     i    循环条件   i/j       输出
4    4    4<=8    1    *
4    5    5<=8    1    *
4    6    6<=8    1    *
4    7    7<=8    1    *
4    8    8<=8    2    #
4    9    9<=8    break    break
****#
因此选D

3. 下列可用于 C 语言程序标识符的一组是（名字间以逗号分隔）：(多选）
A.For, _abc, IF B. _if, _123, file C. void, d, WORD
D. For, -abc, IF E. 2_a, xyz, b1_s

知识点：
* c语言是大小写敏感的语言
* 标识符以字母或下划线开头，有数字字母下划线构成
* 不能使用c语言关键字（保留字）

A 符合
B 符合，file不是c语言的关键字
C 不能有关键词（保留字）void
D -abc "-"减号不能出现在标识符中
E 2_a 不能以数字开头
因此选 A B


4. 对于以下代码：
int i,j=6;
以下哪句话是对的？
A.i 和 j 的初始值都是 6 B. i 被初始为 0，而 j 是 6
C. i 不会被初始化，而 j 是 6 D. 不能通过编译

这个语句做了两件事情：
1. 声明了变量i，和j
2. 对j赋初始值6

因此选C

5. 对于以下代码：
int i;
scanf("%d", &i);
i %= 4
执行后，i 会有几种可能性？
A.7 B. 4 C. 3 D. 2 E.1 F.0

用户输入一个整数i，然后i对于4做取余运算。
这里i可能是正整数0或负整数
对于取余4而言，取余的结果可能是 0、1、2、3、-1、-2、-3
题目问的是有几种可能，那么一共是7种
因此选：A


6. 对于以下代码：
int i=6;
if ( i<= 6 )
printf("hello\n");;
else
printf("bye-bye\n");;
哪句话是对的？（多选）
A. 打印出"hello" B. 无法编译 C. 打印出"bye-bye"
D. 不能通过编译 E. 打印出"hello bye-bye"

* 在没有大括号的情况下这里if后面多出来的分号会导致if和else无法联接，多个分号代表一个空的语句，if在没有大括号的情况下只会和if后面第一条语句结合形成一个if判断分支，如果加赛一条语句，if就是一个独立的判断了，所以不能和后面的else联接上了。
* 我们建议在所有的if分支的后面都加上大括号
因此选 B D


7. 对于以下代码：
int i=6;
do {
printf("%d", i--);
} while (0);
哪句话是对的？
A. 打印出 5 B. 因为 while(0)，无法编译
C. 打印出 6 D. 打印不出东西

* do-while循环至少会执行一次
* i--是i减以前的值，先计算后减，而--i是i减以后的值，先减后运算。
* 0完全等价于逻辑false，但是整数1只是逻辑true的一个子集，任何非零整数都为逻辑true
i的初始值为6，第一次打印为6，i--是减以前的值因此为6，printf执行完后i为5，while条件0始终为false因此循环体只会执行一次。
因此选 C 

8. 对于以下代码：
int i;
for ( i=0; i<10;i++)
printf("%d", i);
for 循环后，i 的值是多少？
A.11 B. 9 C. 10 D. 不确定

我们知道当i < 10 不成立时循环才会终止，也就是说i>=10 那么步进1的情况下i的临界值就是10
因此选 C


9. 下列程序段输出结果为：
int x=1, y=12;
printf(“%d”,y*x++);
A.20 B. 10
C. 24 D. 12

我们知道++、--的优先级要低于四则运算的，并且这是一个后置的自增，++i是加1以前的值，先参与运算在做自增。
1*12  输出12 ，然后x自增一，x=2，y不变，当然我们并不推荐这样的写法，不利于阅读，正确的写法可以把x++拆分到下一个语句执行：
printf(“%d”,y*x);
x++;

因此选D


10. 对
for(表达式 1;;表达式 3)
可理解为
A. for(表达式 1;表达式 1;表达式 3) B. for(表达式 1;1;表达式 3)
C. for(表达式 1; 表达式 3;表达式 3) D. for(表达式 1;0;表达式 3)

这个循环的条件判断被省略掉了，只有初始化和步进的语句，因此也可以当做是一个终止条件始终为1的循环。
也可以用for改写为：for(表达式 1;1;表达式 3);  或 while改写  表达式 1;   while(1){表达式 3}; 当然这个循环如果循环体内部没有break等跳出循环结构的语句的话就是一个死循环。如果有明确的终止条件，我们还是推荐将循环继续条件写在循环体规定的地方，便于阅读。
因此此题选B

11. 以下表达式
x&&1
用在 if 的条件中时，和哪个是等价的（多选）
A.x==0 B. x==1 C. x!=0 D. x!=1 E. x

这里x&&1右边的1始终成立，因此可以看成 x
当x的值不为0逻辑则为true，因此等价于 x != 0 或者 x 
x == 1 只是逻辑true x取值范围的一个子集，因此 x == 1 不等价于 x != 0 或者 x
因此选 C E

我们来运行下面一段代码：
```c
#include <stdio.h>

void main(int argc, char *argv[])
{

 if (-1)
 {
  printf("-1\n");
 }

 if (0)
 {
  printf("0\n");
 }

 if (1)
 {
  printf("1\n");
 }

 if (2)
 {
  printf("2\n");
 }
}

```
测试样例：
```
-1
1
2

--------------------------------
```

我们发现在逻辑表达式的判断中， 当x取非0的任意值时，x会被转换为逻辑true。当然我们并不推荐这种做法，比如你要判断x是否大于0，可以用if(x)来做这件事，看起来很聪明，但是并不好理解，推荐的做法是  int isPositive = x > 0;  if(isPositive)